from typing import List
from classes.Words import Word

class Variables: 
    def __init__(self):
        self.variables: List[Variable] = []
    
    # Add a variable to the list of variables
    def add_variable(self, i, direction, location, verticalEnd, domain):
        
        if self.find_variable_by_id(str(i) + str(direction)) is None:
            self.variables.append(Variable(i, direction, location, verticalEnd, domain))
        else: 
            raise ValueError(f"Variable with id {str(i) + str(direction)} already exists")
        
        
    def get_connecting_words(self, variableIndex):
        """
        Get the starting letter of the connecting words if the variable crosses through other variables
        """
        
        for index in range(variableIndex, len(self.variables)):
            if self.variables[index].direction == "vertical":
                if self.variables[variableIndex].start[1] == self.variables[index].start[1]:
                    print(self.variables[index].word.text[0])
            else:
                if self.variables[variableIndex].start[0] == self.variables[index].start[0]:
                    print(self.variables[index].word.text[0])
    
    def find_variable_by_id(self, id):
        """
        Find a variable by its id
        """
        for variable in self.variables:
            if variable.id == id:
                return variable
        return None
    
    # Generated by ChatGPT 4.o
    # Allow iteration over Variables by iterating over self.variables
    def __iter__(self):
        return iter(self.variables)
    
    # Generated by ChatGPT 4.o
    # Optionally, add __getitem__ if you want to use indexing
    def __getitem__(self, index):
        return self.variables[index]
    
    # Generated by ChatGPT 4.o
    # Optionally, add __len__ to allow len(Variables()) to work
    def __len__(self):
        return len(self.variables)
    
    def __repr__(self):
        # Use a list comprehension to call `repr()` on each variable
        format_variables = "\n".join([repr(variable) for variable in self.variables])
        return f"{format_variables}"
        #return f"{[repr(variable) for variable in self.variables]}"


class Variable:
    def __init__(self, variable, direction, start, end, domain):
        self.variable = variable
        self.id = str(variable) + str(direction)
        self.direction = direction
        self.start = start 
        self.end = end
        self.domain = domain  # Array of strings representing possible values for this variable
        self.word: Word = None  # The word that is assigned to this variable

    # Setters
    def set_direction(self, direction):
        """Update the direction of the variable."""
        self.direction = direction

    def set_starting_cell(self, new_starting_cell):
        """Update the starting cell of the variable."""
        self.starting_cell = new_starting_cell

    def set_word(self, word: Word) -> None:
        """Assign a word to the variable."""
        word.mark_in_use()
        self.word = word
    
    def unset_word(self):
        """Unassign the word from the variable."""
        if self.word:
            self.word.mark_not_in_use()
            self.word = None
        
    # Getters
    def get_direction(self):
        """Return the direction of the variable."""
        return self.direction
    
    def get_word_length(self):
        if self.direction == "horizontal":
            return self.end[1] - self.start[1] + 1
        else:
            return self.end[0] - self.start[0] + 1
        
    def has_word(self):
        """Check if a word is assigned to the variable."""
        return self.word is not None
    
    def __repr__(self):
        
        direction = f"{self.id}"
        starting_cell = f"[{self.start[0]} {self.start[1]}]"  # Left-align starting_cell with width of 14
        ending_cell = f"[{self.end[0]} {self.end[1]}]"
        length = f"{self.get_word_length()}"
        word = ""
   
        
        #domain = f"{', '.join(self.domain)}"     # Join the domain list as a comma-separated string
        
        if self.word: # If a word is assigned to this variable
            word = f"{self.word}"
     
        return f"{direction:<14} | {length:<6} | {starting_cell:<13} | {ending_cell:<11} | {word:<20}"